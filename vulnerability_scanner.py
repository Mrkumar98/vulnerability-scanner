import argparse
import requests
from bs4 import BeautifulSoup
import nmap
import re

def scan_ports(target):
    nm = nmap.PortScanner()
    nm.scan(target, '1-1024')
    for host in nm.all_hosts():
        print(f'Scanning host: {host}')
        for proto in nm[host].all_protocols():
            lport = nm[host][proto].keys()
            for port in lport:
                print(f'Port: {port}\tState: {nm[host][proto][port]["state"]}')

def check_outdated_software(target):
    response = requests.get(target)
    soup = BeautifulSoup(response.text, 'html.parser')
    meta = soup.find('meta', {'name': 'generator'})
    if meta:
        version = meta.get('content')
        print(f'Found software version: {version}')
        # Compare version with known outdated versions (you can maintain a list)
        # ...

def detect_misconfigurations(target):
    response = requests.get(target)
    headers = response.headers
    if 'X-Frame-Options' not in headers:
        print('Missing X-Frame-Options header')
        print('Recommendation: Add X-Frame-Options header to prevent clickjacking attacks. Example: "X-Frame-Options: SAMEORIGIN"')
    if 'Content-Security-Policy' not in headers:
        print('Missing Content-Security-Policy header')
        print('Recommendation: Add Content-Security-Policy header to restrict content sources and mitigate XSS attacks. Example: "Content-Security-Policy: default-src \'self\'; script-src \'self\' https://trusted.cdn.com;"')
    if 'X-Content-Type-Options' not in headers:
        print('Missing X-Content-Type-Options header')
        print('Recommendation: Add X-Content-Type-Options header to prevent MIME type sniffing. Example: "X-Content-Type-Options: nosniff"')
    if 'Strict-Transport-Security' not in headers:
        print('Missing Strict-Transport-Security header')
        print('Recommendation: Add Strict-Transport-Security header to enforce HTTPS. Example: "Strict-Transport-Security: max-age=63072000; includeSubDomains; preload"')

def check_ssl_tls(target):
    print('Checking SSL/TLS configuration...')
    try:
        response = requests.get(target, verify=True)
        print('SSL/TLS configuration looks good. Certificate is valid.')
    except requests.exceptions.SSLError as e:
        print(f'SSL/TTLS error: {e}')
    except requests.exceptions.RequestException as e:
        print(f'Error checking SSL/TLS: {e}')

def check_xss(target):
    print('Checking for XSS vulnerabilities...')
    xss_payload = "<script>alert('XSS')</script>"
    try:
        # Test XSS in query parameters
        response = requests.get(target, params={'q': xss_payload})
        if xss_payload in response.text:
            print('Possible XSS vulnerability detected in query parameter!')
            return
        
        # Test XSS in form fields
        response = requests.post(target, data={'q': xss_payload})
        if xss_payload in response.text:
            print('Possible XSS vulnerability detected in form field!')
            return
        
        # Test XSS in headers
        headers = {'X-Test': xss_payload}
        response = requests.get(target, headers=headers)
        if xss_payload in response.text:
            print('Possible XSS vulnerability detected in headers!')
            return
        
        print('No XSS vulnerabilities detected.')
    except requests.exceptions.RequestException as e:
        print(f'Error checking XSS: {e}')

def check_sql_injection(target):
    print('Checking for SQL injection vulnerabilities...')
    sql_payload = "' OR '1'='1"
    try:
        # Test SQL injection in query parameters
        response = requests.get(target, params={'q': sql_payload})
        sql_errors = [
            "you have an error in your sql syntax;",
            "warning: mysql",
            "unclosed quotation mark after the character string",
            "quoted string not properly terminated",
            "sql syntax",
            "mysql_fetch",
            "mysql_num_rows",
            "is not a valid MySQL result",
            "ORA-01756",
            "SQLSTATE"
        ]
        for error in sql_errors:
            if re.search(error, response.text, re.IGNORECASE):
                print('Possible SQL injection vulnerability detected in query parameter!')
                return
        
        # Test SQL injection in form fields
        response = requests.post(target, data={'q': sql_payload})
        for error in sql_errors:
            if re.search(error, response.text, re.IGNORECASE):
                print('Possible SQL injection vulnerability detected in form field!')
                return
        
        # Test SQL injection in headers
        headers = {'X-Test': sql_payload}
        response = requests.get(target, headers=headers)
        for error in sql_errors:
            if re.search(error, response.text, re.IGNORECASE):
                print('Possible SQL injection vulnerability detected in headers!')
                return
        
        print('No SQL injection vulnerabilities detected.')
    except requests.exceptions.RequestException as e:
        print(f'Error checking SQL injection: {e}')

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Basic Vulnerability Scanner')
    parser.add_argument('target', type=str, help='Target URL or IP address')
    args = parser.parse_args()

    target = args.target
    print(f'Scanning target: {target}')
    scan_ports(target)
    check_outdated_software(target)
    detect_misconfigurations(target)
    check_ssl_tls(target)
    check_xss(target)
    check_sql_injection(target)
